dear imgui
问题与待办事项列表

问题编号 (#) 指向 GitHub 上的问题，地址为 https://github.com/ocornut/imgui/issues/XXXX
此列表维护不善。如今大部分工作都在 GITHUB 上进行。
下面的列表主要包含在用户请求/讨论之前记下的一些想法（那时它们通常已经存在于 github 问题跟踪器中）。
这主要是一些个人笔记，可能不完整。如果您有任何问题，请随时询问。

- 文档：添加一个合适的文档系统（也许依赖自动化？#435）
- 文档：用于验证后端/imgui 集成的清单应用程序（测试输入、渲染、回调等）。
- 文档/提示：每日提示：网站？imgui_club 中的小程序？

- 窗口：保留/恢复相对焦点顺序（持久或非持久），例如多个重新出现的窗口 (#2304) -> 另请参阅 docking 对同一 # 的引用。
- 窗口：每帧使用 <= 0 调用 SetNextWindowSize() 不起作用，允许这样做可能很有用（特别是在用于单个轴时）。(#690)
- 窗口：为非常瞬态的窗口（未保存、临时覆盖数百个对象的窗口）添加一种从全局窗口列表中“清理”的方法。也许是一个轻量级的显式清理过程。
- 窗口：当用户依赖任何动态布局（窗口宽度乘数、列）时，自动适应的反馈循环对最终用户来说显得很奇怪。需要澄清。
- 窗口：以 *p_open == false 开始的 begin 可能会返回 false。
- 窗口：为 get size/pos 辅助函数命名（参见 #249 中的讨论）
- 窗口：当窗口非常小时，优先考虑调整大小按钮而不是关闭按钮。
- 窗口：双击标题栏最小化不是一致的交互，也许可以移到最左边的折叠图标上单击？
- 窗口：公开内容大小。(#1045)
- 窗口：在 Begin() 内部使用 SetWindowPos() 并用鼠标移动窗口会产生非常难看的故障。我们应该推迟 SetWindowPos() 的调用。
- 窗口：未计算时 GetWindowSize() 返回 (0,0)？(#1045)
- 窗口：研究新窗口更好的自动定位。
- 窗口：最顶层窗口标志？更多的 z-order 控制？(#2574)
- 窗口/大小：手动触发的自动适应（双击手柄）不应将窗口大小调整到视口大小？
- 窗口/大小：如何允许例如垂直自动调整以适应内容，但水平可调整大小？假设 SetNextWindowSize() 被修改为将每个轴上的 -1.0f 视为“保持原样”（这会很好，但可能会破坏错误的代码）：问题是 UpdateWindowManualResize() 和许多代码将 (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0) 一起处理。
- 窗口/优化：冻结窗口标志：如果未聚焦/悬停，则返回 false，使用先前的 ImDrawList 渲染。和/或降低刷新率。-> 这可能需要强制规定如果 Begin 返回 false 则提交内容是非法的。
- 窗口/剪裁：当 DisplaySize（或相应的视口）为零时进行某种形式的剪裁。
- 窗口/制表：添加一种表示窗口或停靠窗口需要注意的方式（例如闪烁的标题栏，尝试在模态窗口后面单击）。
- 窗口/id_stack：添加例如 window->GetIDFromPath() 并支持前导 / 和 ../ (#1390, #331) -> 从测试引擎建模。
! 滚动：即使在禁用滚动条时，使用 Shift+Wheel 暴露水平滚动也会暴露许多问题 (#2424, #1463)
- 滚动：按住滚动条时，尝试保持相同的内容可见（至少在不移动鼠标时）
- 滚动：如果我们还没有附加项目，则允许在 Begin() 之后立即生效的滚动更改。
- 滚动：当处于滚动限制边缘时，将鼠标滚轮滚动转发到父窗口？（对列表框、表格有用？）
- 滚动/样式：在可滚动区域上添加阴影以表示有更多内容（参见例如 DaVinci Resolve ui）

- drawdata：使其易于深度复制（或交换？）完整的 ImDrawData，以便用户在使用线程渲染时可以轻松保存该数据。(#1860 参见 ImDrawDataSnapshot)
! drawlist：添加 CalcTextSize() 函数以方便用户 pov 的一致代码（当前需要使用 ImGui 或 ImFont 的替代方案！）
- drawlist：为每个命令维护边界框将允许在不依赖剪裁时合并绘制命令（典型的非滚动窗口或非溢出列将与前一个命令合并）。（WIP 分支）
- drawlist：使其更容易为每个图元切换 AA，这样我们就可以更自然地使用例如非 AA 填充 + AA 边框
- drawlist：非 AA 笔划在点之间有间隙 (#593, #288)，在 RenderCheckmark() 和 ColorPicker4() 上尤其明显。
- drawlist：回调：在 ImDrawCallback 中添加一个额外的 void* 以公开渲染状态，而不是从 Renderer_RenderState 中提取（会破坏 API）。
- drawlist：AddRect vs AddLine 位置令人困惑 (#2441)
- drawlist/opt：将圆角存储在纹理中，以便每个角使用 1 个四边形（填充和线框）以降低圆角成本。(#1962)
- drawlist/opt：AddRect() 轴对齐像素对齐（无 aa）可以使用 8 个三角形而不是 16 个，并且无需计算法线。
- drawlist/opt：通过在图集中存储渐变+全色，可以在与 1.0 AA 线相同数量的三角形中实现粗 AA 线。

- 项目：IsItemHovered() 信息存储在堆栈中？以便 'if TreeNode() { Text; TreePop; } if IsHovered' 返回 TreeNode 的悬停状态？

- 小部件：显示模式：小部件-标签、标签-小部件（在列上对齐或使用固定大小）、标签-换行-制表符-小部件等。(#395)
- 小部件：清理小部件内部，以公开所有内容并稳定 imgui_internals.h。
- 小部件：添加始终允许重叠模式。这也许应该是默认设置？一个问题是鼠标滚轮滚动后的高亮显示被延迟，使滚动更加闪烁。
- 小部件：开始公开 PushItemFlag() 和 ImGuiItemFlags
- 小部件：样式中的对齐选项（例如居中 Selectable，在 Button 内右对齐等）#1260
- 小部件：按标识符激活（触发按钮，聚焦给定 id）
- 小部件：用于库存形状的自定义字形/形状替换。（也 #6090 #2431 #2235 #6517）
- 小部件：coloredit：当选择器打开时，是否继续报告为活动状态？
- 小部件：group/scalarn 函数：公开更多每个组件的信息。例如，存储由 scalarn 函数设置的 NextItemData.ComponentIdx，组可以以某种方式将其公开。
- selectable：当前不支持使用 (size.x == 0.0f) 和 (SelectableTextAlign.x > 0.0f) 后跟 SameLine()。
- selectable：通用的 BeginSelectable()/EndSelectable() 机制。（与 range-select 分支一起解决）
- selectable：一种可视化部分/混合选择的方法（例如，父树节点具有混合选择的子节点）

- input text：取消聚焦时保留滚动？
- input text：重组事件处理，允许 CharFilter 修改缓冲区，允许多个事件？(#541)
- input text：在 char filter 事件中公开 CursorPos (#816)
- input text：尝试使用仅通过 get/set 访问器公开的数据的 InputText，无需额外的复制/分配。(#3009)
- input text：通过非回调 API 访问公共字段，例如 InputTextGetState("xxx")，如果未激活，则可能返回 nullptr（在内部可用）
- input text：禁用用户缓冲区实时更新的标志（也适用于 float/int 文本输入）(#701)
- input text：悬停工具提示可以显示未剪裁的文本
- input text：支持 INSERT 键切换覆盖模式。当前已禁用，因为 stb_textedit 在多行上的行为不令人满意。(#2863)
- input text：在 Enter 验证后使用 Tab 的选项。
- input text：添加 ImGuiInputTextFlags_EnterToApply？(关闭 #218)
- input text：在拥有时更容易更新缓冲区（从源 char*）。为多行文本保留某种光标位置。
- input text：添加丢弃标志（例如 ImGuiInputTextFlags_DiscardActiveBuffer）或使其更容易清除活动焦点以在编辑期间进行文本替换 (#725)
- input text：在不同窗口中单击拖动/滑块后，在具有全选文本的输入文本后单击时出现显示错误（顺序相关）。实际上是一个非常古老的错误，但似乎没有人注意到它。
- input text：允许居中/定位文本，以便 ctrl+单击拖动或滑块将文本值保持在相同的像素位置。
- input text：将显示布局与带有自定义模板的输入解耦 - 例如，实现一个漂亮的 IP/Mac 地址输入编辑器的最简单方法是什么？
- input text：全局回调系统，以便用户可以轻松插入表达式求值器。(#1691)
- input text：强制滚动到末尾或滚动到给定的行/内容（以便用户可以实现日志或搜索功能）
- input text：一种预览完成的方式（例如，从光标处完成的禁用文本）
- input text：一个可以例如预览错误位置的侧边栏。可能留给用户绘制，但我们需要给他们那里的信息。
- input text：一种供用户提供语法着色的方法。
- input text：使用 ImGuiInputTextFlags_AllowTabInput 的 Shift+TAB 可以吃掉前面的空格，最多 tab_count。
- input text multi-line：不要直接调用 AddText()，它在剪裁之前为字符数进行不必要的顶点保留。和/或更多基于行的剪裁到 AddText()。和/或重组 TextUnformatted/RenderText 以提高大文本的效率（例如 TextUnformatted 可以单独剪裁和记录等）。
- input text multi-line：支持不选择的复制/剪切（复制/剪切当前行？）
- input text multi-line：行号？状态栏？（跟进 #200）
- input text multi-line：当用户在编辑活动时更改输入缓冲区时表现更好（即使这是非法行为）。即，缓冲区的更改可能会产生滚动条故障 (#725)
- input text multi-line：更好的水平滚动支持 (#383, #1224)
- input text multi-line：对 AddText() 的单次调用应在 InputTextEx() 结束时进行粗略剪裁。
- input number：Input*() 函数的可选范围 min/max
- input number：按住 [-]/[+] 按钮可以非线性地（或用户控制地）增加步进速度
- input number：使用鼠标滚轮步进上/下

- 布局：辅助函数或一种以更简单的方式表达 ImGui::SameLine(ImGui::GetCursorStartPos().x + ImGui::CalcItemWidth() + ImGui::GetStyle().ItemInnerSpacing.x) 的方法。
- 布局，字体：水平制表符支持，A) 文本模式：仅向前制表符（例如，从 pos x1 开始每 4 个字符/N 个像素），B) 手动模式：显式制表符充当迷你列，无剪裁（用于菜单项，多种用途，也与 #267, #395 模糊相关）
- 布局：水平布局辅助函数 (#97)
- 布局：水平流动直到没有空间 (#404)
- 布局：更通用的单个项目对齐状态（左/右/居中）？
- 布局：清理 InputFloatN/SliderFloatN/ColorEdit4 布局代码。项目宽度应包括框架填充。
- 布局：同一行内混合高度项目（例如按钮）的垂直对齐 (#1284)
- 布局：空布局模式，其中项目不被渲染，但用户可以查询 GetItemRectMin()/Max/Size。
- 布局：(研发) 本地多遍布局模式。
- 布局：(研发) 绑定创作的布局数据（由离线工具创建），项目在提交时获取其 pos/size，自优化数据结构以实现稳定的线性访问。

- 表格：参见 https://github.com/ocornut/imgui/issues/2957#issuecomment-569726095

- 组：BeginGroup() 需要一个边框选项。(~#1496)
- 组：EndGroup() 之后的 IsItemHovered() 覆盖整个 AABB 而不是单个项目的交集。这是否可取？
- 组：在同一组内合并停用/激活（转发 WasEdited 标志）。(#2550)

!- 颜色：颜色转换辅助函数/类型一团糟，需要整理。
- 颜色：（API 重大变更）ImGui::ColorConvertXXX 函数应该是松散的 ImColorConvertXX 以匹配 imgui_internals.h

- 绘图：功能齐全的绘图/图形 api，带滚动、缩放等功能 -> 推广使用 ImPlot
- (绘图：于 2023-06-28 删除了所有其他待办事项行)

- 剪裁器：能够通过一个简单的标志/布尔值禁用剪裁。
- 剪裁器：能够在不预先知道总数的情况下运行。
- 剪裁器：水平剪裁支持。(#2580)

- 分隔符：公开标志 (#759)
- 分隔符：考虑缩进（可选）
- 分隔符：宽度、厚度、居中 (#1643, #2657)
- 分隔器：将分隔器习语形式化为官方 api（我们希望处理 n 路分割）(#319)

- 停靠：合并停靠分支 (#2109)

- 标签页：“当前存在一个问题，因为 TabItem() 会在 0.50 秒后尝试提交自己的工具提示，这将导致您的工具提示闪烁一次。” -> 工具提示优先级工作（WIP 分支）
- 标签页：如果用户不遵守 BeginTabBar 返回值，则使 EndTabBar 失败，以保持一致性/未来兼容性。
- 标签页：BeginTabBar() api 中的持久顺序/焦点 (#261, #351)
- 标签页：用于清晰地操作标签顺序的显式 api（即使是内部的）。

- 图像/图像按钮：在带填充/边框的按钮上未对齐？
- 图像/图像按钮：参数令人困惑，image() 有 tint_col,border_col 而 imagebutton() 有 bg_col/tint_col。即使它们是不同的参数，顺序也可以更一致。我们能解决这个问题吗？
- 滑块：允许使用 InputFloat()/InputInt() 使用的 [-]/[+] 按钮
- 滑块：添加基于拖动的小部件以使用鼠标编辑值（在 2 个轴上），节省屏幕空间。
- 滑块：根据值对背景进行着色（例如 v_min -> v_max，或在符号的任一侧使用 0.0f）
- 滑块：相对拖动？+ 精密拖动
- 滑块：步进选项 (#1183)
- 滑块：样式：填充条的百分比，而不是定位拖动。
- 旋钮：旋转旋钮小部件 (#942)
- 拖动浮点数：支持反向拖动（min > max）（移除了 is_locked，另请参见 fdc526e）
- 拖动浮点数：上/下轴
- 拖动浮点数：当当前值超出范围时，power != 0.0f 会使值卡住。
- 拖动浮点数：在边缘添加余地（例如，在钳位限制之外有几个不可见的步长）

- 组合框：一种/辅助函数来自定义组合框预览 (#1658) -> 实验性的 BeginComboPreview()
- 组合框/列表框：键盘控制。需要类似 InputText 的非活动焦点 + 按键处理。考虑为自定义列表框使用键盘 (pr #203)
- 列表框：多选（WIP range-select 分支）
- 列表框：取消选择选项 (#1208)
- 列表框：使其更容易/更自然地实现范围选择（需要一些关于最后单击/聚焦项目的信息/引用，用户可以将其转换为索引？）（WIP range-select 分支）
- 列表框：用户可能希望初始滚动以聚焦于一个选定的值？
- 列表框：如果列表框没有滚动，则禁用捕获鼠标滚轮。(#1681)
- 列表框：滚动应跟踪修改后的选择。
- 列表框：未来的 api 应允许启用水平滚动 (#2510)

!- 弹出窗口/菜单：阐明弹出窗口 id 的用法，MenuItem/Selectable 关闭父弹出窗口如何影响 ID 等。这非常可疑，需要改进！(#331, #402)
- 模态窗口：当尝试在模态窗口外部单击时，使模态窗口标题栏闪烁
- 模态窗口：从技术上讲，我们可以使带有 ImGuiWindowFlags_Modal 的 Begin() 在不涉及弹出窗口的情况下工作。可能有助于理清一些事情，因为模态窗口更像常规窗口而不是弹出窗口。
- 弹出窗口：如果弹出函数采用显式 ImGuiID，它将允许用户管理这些 ID 的范围。(#331)
- 弹出窗口：在外部单击（以关闭弹出窗口）并按住不应拖动下面的窗口。
- 弹出窗口：添加使用类似于 Begin/End 的全局标识符的变体 (#402)
- 弹出窗口：边框选项。更丰富的 api，如 BeginChild()？(#197)
- 弹出窗口/模态窗口：虽然弹出窗口/模态窗口的生命周期由 imgui 拥有有时很方便，但只要强制执行 Begin() 返回值测试，我们也可以使用用户拥有的布尔值 api。

- 工具提示：在显示器边缘附近拖放带有工具提示的项会丢失/更改其最后的方向，而不是锁定一个方向。拖放工具提示应始终跟随而不改变方向。
- 工具提示：允许设置工具提示的宽度以允许 TextWrapped() 等，同时保持高度自动。
- 工具提示：拖动工具提示悬停在带有 IsItemHovered/SetTooltip 的源小部件上会闪烁（WIP 分支）
- 工具提示：工具提示优先级以覆盖库存工具提示（例如快捷方式工具提示）

- 状态栏：添加一个类似于菜单栏的每个窗口的状态栏辅助函数。概括窗口中 layer0 rect 的概念（也可以使 _MenuBar 窗口标志过时）。
- 快捷方式：在 ImGuiKeyChord 中存储多个组合键
- 快捷方式：悬停路由（低于聚焦，高于全局）
- 快捷方式：本地样式快捷方式 api，例如解析“&保存”
- 快捷方式，菜单：全局样式快捷方式 api，例如“保存 (CTRL+S)” -> 用于递归到关闭菜单的显式标志
- 菜单：在菜单栏上从一个菜单悬停到另一个菜单时，有 1 帧没有任何菜单，这有点烦人。理想情况下为零。
- 菜单：如果 Selectable() 支持水平对齐会很好（必须给定与快捷方式列位置匹配的 WorkRect.Max.x 等效项）

- 树节点：添加 treenode/treepush int 变体？不存在是因为从 int 进行 (void*) 转换在某些平台/设置上会发出警告？
- 树节点：如果节点刚刚打开并且节点末尾超过滚动限制，则尝试在 TreePop() 时应用滚动？
- 树节点/可选择的渲染不匹配，如果您将它们并排使用（例如，参见属性查看器），则可见
- 树节点：调整配色方案以区分标题和选定的树节点 (#581)
- 树节点：叶/非叶高亮不匹配。
- 树节点/优化：可以在剪裁时避免格式化（标志假设我们不关心宽度/高度，假设单行高度？仅格式化 %s/%c 以便能够计算高度？）

- 设置：编写更像样的代码以允许保存/加载新字段：列、选定的树节点？
- 设置：方便扩展在运行时延迟调用 AddSettingsHandler() 并且仍然让它们的数据立即调用 ReadXXX 处理程序。
- 设置：用于在 .ini 文件中存储每个工具的简单持久数据的 api（布尔值、整数、浮点数、列大小等）(#437)
- 设置/持久性：使 TreeNodeBehavior 持久化的辅助函数（即使在开发期间！） - 可能需要在 ImGuiStoragePair 中存储一些语义和/或数据类型

- 样式：更好的默认样式。(#707)
- 样式：添加高亮文本颜色（用于标题等）
- 样式：边框类型：屏幕外、屏幕内等。(#447)
- 样式：添加窗口阴影（从窗口淡出。绘制列表后绘制样式的顶点 alpha 计算会更容易）
- 样式：最终用户可以轻松依赖的“紧凑样式”概念（例如 PushStyleCompact()？），映射到其他设置？避免实现重复的辅助函数，例如 SmallCheckbox() 等。
- 样式：尝试使 PushStyleVar() 对不正确的参数更健壮（以便对编辑和继续情况更友好）。
- 样式：全局缩放设置。
- 样式：FramePadding 对于上/下可以不同 (#584)
- 样式：WindowPadding 需要是偶数，因为用于此值的 0.5 乘数可能对剪裁矩形有细微影响
- 样式：具有更全局的 HSV 设置器（例如，更改所有元素的色调）。考虑用 HSV 空间中的偏移量替换 active/hovered？(#438, #707, #1223)
- 样式：渐变填充 (#1223) ~ 每个填充 2 个背景颜色？对于圆角形状和使用纹理作为角点来说很棘手。
- 样式编辑器：颜色子窗口高度以行高的倍数表示。

- 日志：改进 ArrowButton、ListBox、TabItem 的日志记录
- 日志：打开子窗口时继承缩进/树深度
- 日志：启用日志最终会推送和增长顶点缓冲区，因为我们不区分布局和渲染剪裁
- 日志：对日志范围有更多控制（例如，离开当前树节点范围时停止日志记录）
- 日志：能够记录任何内容（例如，右键单击窗口/树节点，显示上下文菜单？记录到 tty/文件/剪贴板）
- 日志：让用户轻松地将任何窗口内容复制到剪贴板（在窗口上按 CTRL+C？移动时？上下文菜单？）。代码被注释掉了，因为它在多个 Begin/End 对中失败。
- 日志：废弃 LogButtons()....（以前是：LogButtons() 用于指定深度和/或隐藏深度滑块的选项）

- 过滤器：设置一个当前过滤器，某些项目（例如树节点）可以自动查询以隐藏自己
- 过滤器：处理通配符（带有隐式的前导/尾随 *），正则表达式
- 过滤器：模糊匹配（可以使用 blog.forrestthewoods.com/4cffeed33fdb 的代码）

- 拖放：按住时聚焦拖动目标窗口（即使未打开）
- 拖放：释放拖放时会显示“...”工具提示一帧 - 自 e13e598 起 (#1725)
- 拖放：在组对象上拖动源（需要在 EndGroup 中覆盖组的不可见按钮）https://twitter.com/paniq/status/1121446364909535233
- 拖放：有一些方法可以知道从 BeginDragDropSource() pov 开始拖动的时间。（参见 #143 中的 2018/01/11 帖子）
- 拖放：允许从与拖动源不同的位置提交预览工具提示。(#1725)
- 拖放：使其更容易并提供一个演示，以便在源和目标站点都有工具提示，在目标站点有更详细的工具提示（工具提示排序问题）
- 拖放：演示重新排序节点（在列表或树节点中）。(#143)
- 拖放：测试与操作系统拖放的集成（使其易于进行简单的 WM_DROPFILE 集成）
- 拖放：允许多种有效负载类型。(#143)
- 拖放：使有效负载可选？有效负载承诺？（参见 #143 中的 2018/01/11 帖子）
- 拖放：(#143) “进程内指针和生成序列化版本的承诺，无论拖动是在同一进程内部还是外部结束”
- 拖放：当悬停在被模态窗口阻止的区域时提供反馈（鼠标光标“NO”？）

- 标记：用于颜色更改的简单标记语言？(#902, #3130)

- 文本：可选择的文本（用于复制）作为通用功能（ItemFlags？）
- 文本：imgui_internal.h 中的正确对齐选项
- 文本：提供一个带框的文本辅助函数，例如 https://pastebin.com/1Laxy8bT
- 文本：重构 TextUnformatted（或底层函数）以更明确地请求我们是否需要宽度测量
- 文本/布局/制表符：\t 从基本位置 + 步长或偏移数组中提取位置（例如，可用于文本编辑、菜单以实现简单的图标+文本对齐等）
- 文本链接/url 按钮：带下划线。api 应该公开一个 ID 还是使用文本内容作为 ID？使用哪个颜色枚举？
- 文本/换行：应该是一个更一等的公民，例如，在具有已知宽度的 Selectable 中换行文本。
- 文本/换行：用于文本换行的自定义分隔符。(#3002)
- 文本/换行：找出在始终自动调整大小的上下文（工具提示等）中使用 TextWrapped() 的更好方法 (#249)

- 字体：任意行距。(#2945)
- 字体：MergeMode：选择是否覆盖的标志（现在使用重构的 ImFontAtlasBuildWithStbTruetype 很容易）
- 字体：更好的 CalcTextSizeA() API，至少对于简单的用例。当前的很糟糕（也许有简单版和扩展版）。
- 字体：为了 RenderTextEllipsis() 的目的，CalcTextSizeA() 可以忽略尾随填充可能很有用？
- 字体：CalcTextHeight() 辅助函数可以比 CalcTextSize().y 运行得更快
- 字体：通过 ImFontConfig 强制等宽（用于图标？）+ 从同一输入创建双 ImFont 输出，重用光栅化数据但使用不同的字形/AdvanceX
- 字体：使其更容易提交自己的位图字体（相同的纹理，另一个纹理？）。(#2127, #2575)
- 字体：MemoryTTF 取得所有权令人困惑/不明显，也许默认值应该相反？
- 字体：存储每个字体的 MinAdvanceX 将允许我们在寻找块宽度的循环中跳过计算行宽（在字符数阈值下）
- 字体/演示：演示 ImFontGlyphRangesBuilder 的用法。
- 字体/绘制：垂直和/或旋转的文本渲染器 (#705) - 垂直在剪裁方面更容易
- 字体/绘制：需要能够指定换行起始位置。
- 字体/绘制：更好地为大水平文本块保留策略（不应为所有剪裁的行保留）。另请参见 #3349。
- 字体/绘制：修复在同一次调用中绘制 16k+ 可见字符的问题。
- 字体/绘制：下划线、波浪线渲染辅助函数。
- 字体：优化：对于等宽字体（如默认字体），只要尾随值 == FallbackXAdvance，我们就可以修剪 IndexXAdvance（需要确保 TAB 仍然正确），这将节省缓存行。
- 字体：添加对字距调整的支持，可能是可选的。A) 也许默认为 (32..128)^2 矩阵 ~ 9K 条目 = 36KB，然后对非 ascii 进行哈希？B) 或者稀疏查找到每个字符的列表？
- 字体：添加一个更简单的 CalcTextSizeA() api？当前的可以，但如果用户需要直接调用它（不通过 ImGui::CalcTextSize），则不受欢迎
- 字体：（API 重大变更）从符号名称中删除“TTF”。也因为它现在支持 OTF。
- 字体/优化：考虑将独立的 AdvanceX 表存储为 16 位定点整数？
- 字体/优化：字形当前为 40 字节 (2+9*4)。考虑将 UV 存储为 16 位整数？(->32 字节)。X0/Y0/X1/Y1 作为 16 位定点整数？或者 X0/Y0 作为浮点数，X1/Y1 作为定点 8_8？

- 导航：某些功能，如 PageUp/Down/Home/End，可能应该在没有 ImGuiConfigFlags_NavEnableKeyboard 的情况下工作？（我们在哪里划清界限？CTRL+Tab 怎么样）
- 导航：当可导航项目在滚动边缘不完全可见时，Home/End 的行为？是否应该回溯以使项目保持在视图中？
- 导航：NavScrollToBringItemIntoView() 在项目大于视图时应聚焦于右上角？复现：在“关于窗口”中使用导航
- 导航：向允许例如基于网格的布局公开环绕标志/逻辑（在最右边的元素上按 NavRight 会转到下一行等）。参见内部的 NavMoveRequestTryWrapping()。
- 导航：使箭头键能够更新选择的模式（参见 range_select 分支中的 JustMovedTo）
- 导航：当当前 NavId 消失时恢复/查找最近的 NavId（例如，按下一个消失的按钮，或者当当前按钮更改名称时自动恢复）
- 导航：SetItemDefaultFocus() 优先级，以便像弹出窗口内的 Selectable 这样的小部件可以在第一个选定项目上声明一个低优先级的默认焦点
- 导航：按住空格键重复一个按钮在按住期间不显示按钮已激活。
- 导航：NavFlattened：初始化请求在扁平化的兄弟节点上无法正常工作。
- 导航：NavFlattened：pageup/pagedown/home/end 在扁平化的兄弟节点上无法正常工作。
- 导航：NavFlattened：在扁平化的子节点上按 ESC 应该选择某些东西。
- 导航：NavFlattened：损坏：在典型的使用场景中，完全剪裁的子节点的项目当前不被考虑进入 NavFlattened 子节点。
- 导航：NavFlattened：无法使用 Alt/菜单键访问扁平化子窗口的菜单栏（不是很常见的用例..）。
- 导航：模拟右键单击或上下文激活？（SHIFT+F10，键盘菜单键？）
- 导航/弹出窗口：弹出窗口的 esc/enter 默认行为，例如能够标记一个“确定”或“取消”按钮，这些按钮将由这些键触发，默认验证按钮等。
- 导航/树节点：在树节点块内向左作为后备（默认情况下为 ImGuiTreeNodeFlags_NavLeftJumpsBackHere？）
- 导航/菜单：在垂直剪裁的菜单栏上按左右键倾向于跳转到折叠/关闭按钮。
- 导航/菜单：允许按菜单键离开子菜单。
- 导航/菜单：一种使用 Alt 访问主菜单栏的方法？（当前需要 CTRL+TAB）或上次聚焦的窗口菜单栏？
- 导航/菜单：使用主菜单栏时，即使我们之后恢复了焦点，底层窗口在菜单操作期间也会失去其标题栏高亮。我们能阻止它吗？
- 导航/菜单：主菜单栏当前无法恢复空指针焦点。可以像弹出窗口一样在聚焦时保存 NavWindow 吗？
- 导航/菜单：Alt,Up 可以打开第一个菜单（例如“文件”），当前它倾向于导航到窗口/折叠菜单。要做到这一点，我们需要自定义转换吗？
- 导航/窗口：当 CTRL+Tab/窗口活动时，HoveredWindow 检测不考虑窗口显示重新排序。
- 导航/窗口：在应用某些类型的调整大小约束/回调时，调整窗口大小当前会失败
- 焦点：保留 ActiveId/焦点堆栈状态，例如，当打开一个菜单并关闭它时，先前选择的 InputText() 焦点会恢复 (#622)

- 输入：支持触控板式滚动和滑块编辑。
- 输入/io：在文本输入上下文中，退格键和箭头键可以使用系统重复率。
- 输入/io：阐明/标准化/公开重复率和重复延迟 (#1808)
- 输入/滚动：支持平滑滚动 (#2462, #2569)

- 其他：空闲：公开“唤醒”布尔值（由输入设置）和/或动画时间（用于光标闪烁），以便后端可以轻松停止刷新。
- 其他：空闲：如果光标闪烁是*唯一*可见的动画，核心 imgui 可以重写顶点 alpha 以避免在 ImGui:: 调用上进行 CPU 传递。
- 其他：空闲：如果光标闪烁是*唯一*可见的动画，甚至可以公开一个脏矩形，某些应用程序可以选择性地利用它在较小的视口中渲染，从而消除大量的像素着色成本。
- 其他：由于堆栈中始终有一个调试窗口，因此无法使用 ImGui:: api 运行根级的 GetID()。（在 #2960 中提到）
- 其他：使 ImGuiCond 值为线性（非二次幂）。ImGuiWindow 的内部存储可以使用整数组合成标志（为什么？）
- 其他：PushItemFlag()：添加一个标志以在与鼠标一起使用时禁用键盘捕获？(#1682)
- 其他：在公共 api 中使用更多 size_t？
- 其他：支持字符串视图/范围而不是 char* 将例如方便与 Rust 一起使用 (#683, #3038, WIP string_view 分支)

- 演示：更详细地演示使用 PushStyleVar()。
- 演示：添加垂直分隔符演示
- 演示：添加虚拟滚动示例？
- 演示：演示绘图偏移
- 演示：窗口大小约束：从边缘调整大小时，方形演示已损坏 (#1975)，需要重构回调系统来解决此问题

- 示例：窗口最小化、最大化 (#583)
- 示例：提供一个零帧率/空闲示例。
- 示例：dx11/dx12：尝试使用新的交换链 blit 模型 (#2970)
- 后端：无法创建纹理时更好地报告？
- 后端：glfw：最小化时可以进入空闲状态吗？if (glfwGetWindowAttrib(window, GLFW_ICONIFIED)) { glfwWaitEvents(); continue; } // 问题：恢复时 DeltaTime 会非常高，也许提供一种让 impl 知道的方法 (#440)
- 后端：opengl：将 imgui_impl_opengl2 重命名为 impl_opengl_legacy，将 imgui_impl_opengl3 重命名为 imgui_impl_opengl？(#1900)
- 后端：opengl：可以使用单个顶点缓冲区和 glBufferSubData 进行上传吗？
- 后端：opengl：在绑定中明确禁用 GL_STENCIL_TEST。
- 后端：vulkan：视口：支持多个交换链的同步交换。
- 后端：bgfx：https://gist.github.com/RichardGale/6e2b74bc42b3005e08397236e4be0fd0
- 后端：emscripten：通过重构的示例，我们可以提供一个直接的 imgui_impl_emscripten 平台层（参见例如 https://github.com/floooh/sokol-samples/blob/master/html5/imgui-emsc.cc#L42）

- 绑定：使用 clang ast dump 生成绑定或绑定的辅助函数的方法？（例如 clang++ -Xclang -ast-dump=json imgui.h）（--> 使用 https://github.com/dearimgui/dear_bindings）

- 优化：用 stb_printf 替换 vsnprintf？使用 IMGUI_USE_STB_SPRINTF。(#1038 + string_view 需要）
- 优化：为多组件小部件（SliderFloatX、ColorEditX 等）添加剪裁。一个问题是，当有移动请求时，导航分支无法轻松剪裁父组。
- 优化：添加一个标志以禁用大部分渲染，以备用户希望跳过它 (#335)
- 优化：完全覆盖的窗口（被另一个具有不透明背景的窗口覆盖 + WindowRounding 值的填充）可能希望剪裁渲染。
- 优化：使用另一个哈希函数而不是 crc32，例如 FNV1a
- 优化：将一些各种堆栈向量转换为静态大小的数组
